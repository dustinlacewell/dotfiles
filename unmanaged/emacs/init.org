#+title: ldlework's init.el
#+startup: overview align
#+babel: :cache no
#+Options: ^:nil num:nil tags:nil
#+PROPERTY: header-args    :tangle yes

This config is best viewed in Emacs!

* bootstrap
** lexical binding
Activate help:lexical-binding for the entire config.

#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

** package management via straight.el
[[https://github.com/raxod502/straight.el][straight.el]] is an alternative to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Packages.html][package.el]] with many advantages including the
ability to integrate with [[https://github.com/jwiegley/use-package][use-package]] and installing packages from git or
github.

#+begin_src emacs-lisp
  (let ((bootstrap-file (concat user-emacs-directory "straight/repos/straight.el/bootstrap.el"))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage)
    (setq straight-vc-git-default-clone-depth 1))
#+end_src

*** use-package integration
#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
  (straight-use-package 'use-package)
  (use-package git) ;; ensure we can install from git sources
#+end_src

** general dependencies
The following package dependencies are used throughout the rest of the
configuration. They provide modern APIs for working with various elisp data
structures.

#+begin_src emacs-lisp
  (require 'cl-lib)
  (require 'seq)
  (use-package f :demand t)          ;; files
  (use-package dash :demand t)       ;; lists
  (use-package ht :demand t)         ;; hash-tables
  (use-package s :demand t)          ;; strings
  (use-package a :demand t)          ;; association lists
  (use-package anaphora :demand t)   ;; anaphora
#+end_src

** boilerplate
Calculate file paths relative to various locations.

*** my/get-org-file
#+begin_src emacs-lisp
  (defun my/get-org-file (file-name)
    (concat my/org-directory file-name))
#+end_src

*** my/get-project-directory
#+begin_src emacs-lisp
  (defun my/get-project-directory (name)
    (concat my/projects-directory name))
#+end_src

*** my/get-source-directory
#+begin_src emacs-lisp
  (defun my/get-source-directory (name)
    (concat my/sources-directory name))
#+end_src

* local settings
These settings are specific to current machine.

** linux paths
#+begin_src emacs-lisp
  (when (string-equal system-type "gnu/linux")
    (defvar my/home-directory (expand-file-name "~/"))
    (defvar my/data-directory (concat my/home-directory ".emacs.d/"))
    (defvar my/projects-directory (concat my/home-directory "src/"))
    (defvar my/sources-directory (concat my/home-directory "ext/"))
    (defvar my/org-directory (concat my/home-directory "org/"))
    (defvar my/yas-directory (concat my/data-directory "yasnippet/")))
#+end_src

** windows paths
#+begin_src emacs-lisp
  (when (string-equal system-type "windows-nt")
    (defvar my/home-directory (expand-file-name "b:/"))
    (defvar my/data-directory (concat my/home-directory "Emacs/"))
    (defvar my/projects-directory (concat my/home-directory "Projects/"))
    (defvar my/sources-directory (concat my/home-directory "Sources/"))
    (defvar my/org-directory (concat my/home-directory "Syncthing/Org/"))
    (defvar my/yas-directory (concat my/data-directory "Yas/"))
    (setq linkmarks-file (concat my/org-directory "bookmarks.org")))
#+end_src

** data paths
#+begin_src emacs-lisp
  (defvar my/notes-file-name (my/get-org-file "notes.org") "Main notes file-name")
  (defvar my/bookmarks-file-name (my/get-org-file "bookmarks.org") "Main bookmarks file-name")
  (defvar my/autosaves-directory (concat my/data-directory "autosaves/") "Main bookmarks file-name")
  (defvar my/backups-directory (concat my/data-directory "backups/") "Main bookmarks file-name")
#+end_src

** external browser
#+begin_src emacs-lisp
  (setq browse-url-browser-function 'browse-url-chrome)
  (setq browse-url-chrome-program "google-chrome-stable")
#+end_src

** default zoom
#+begin_src emacs-lisp
  (setq my/default-zoom-level 4)
#+end_src

* helpers
These macros are conveinent shorthands.

** :function
Make non-interactive functions out of forms or a symbol.

e.g. =(:function (message "Hello world.")=
e.g. =(:function foobar)=

#+begin_src emacs-lisp
  (defmacro :function (&rest body)
    (if (->> body length (< 1))
        `(lambda () ,@body)
      (pcase (car body)
        ;; command symbol
        ((and v (pred commandp))
         `(lambda () (call-interactively (quote ,v))))
        ;; function symbol
        ((and v (pred symbolp))
         `(lambda () (,v)))
        ;; quoted command symbol
        ((and v (pred consp) (guard (eq 'quote (car v))) (pred commandp (cadr v)))
         `(lambda () (call-interactively ,v)))
        ;; quoted function symbol
        ((and v (pred consp) (guard (eq 'quote (car v))))
         `(lambda () (,(cadr v))))
        ;; body forms
        (_ `(lambda () ,@body) ))))
#+end_src

** :command
Make interactive commands out of forms or a symbol.

e.g. =(:command (message "Hello world."))=
e.g. =(:command foobar)=

#+begin_src emacs-lisp
  (defmacro :command (&rest body)
    (if (->> body length (< 1))
        `(lambda () (interactive) ,@body)
      (pcase (car body)
        ;; command symbol
        ((and v (pred commandp))
         `(lambda () (interactive) (call-interactively (quote ,v))))
        ;; function symbol
        ((and v (pred symbolp))
         `(lambda () (interactive) (,v)))
        ;; quoted command symbol
        ((and v (pred consp) (guard (eq 'quote (car v))) (pred commandp (cadr v)))
         `(lambda () (interactive) (call-interactively ,v)))
        ;; quoted function symbol
        ((and v (pred consp) (guard (eq 'quote (car v))))
         `(lambda () (interactive) (,(cadr v))))
        ;; body forms
        (_ `(lambda () (interactive) ,@body) ))))
#+end_src

** :after
Defer some forms until the given package is loaded.

e.g. =(:after org (message "Hello world"))=

#+begin_src emacs-lisp
  (defmacro :after (package &rest body)
    "A simple wrapper around `with-eval-after-load'."
    (declare (indent defun))
    `(with-eval-after-load ',package ,@body))
#+end_src

** :hook
Register some forms or a symbol with a hook.

e.g. =(:hook org-mode (message "hello world")=
e.g. (:hook org-mode foobar)

#+begin_src emacs-lisp
  (defmacro :hook (hook-name &rest body)
    "A simple wrapper around `add-hook'"
    (declare (indent defun))
    (let* ((hook-name (format "%s-hook" (symbol-name hook-name)))
           (hook-sym (intern hook-name))
           (first (car body))
           (local (eq :local first))
           (body (if local (cdr body) body))
           (first (car body))
           (body (if (consp first)
                     (if (eq (car first) 'quote)
                         first
                       `(lambda () ,@body))
                   `',first)))
      `(add-hook ',hook-sym ,body nil ,local)))
#+end_src

** :push
A wrapper around help:add-to-list.

e.g. =(:push some-list 1 2 3)=

#+begin_src emacs-lisp
  (defmacro :push (sym &rest body)
    (declare (indent defun))
    (if (consp body)
        `(setq ,sym (-snoc ,sym ,@body))
      `(add-to-list ,sym ,body)))
#+end_src

** :bind
Bind some forms or a symbol to a key.

e.g. =(:bind "C-m" (message "Hello world."=
e.g. =(:bind org-mode "C-m" (message "Hello world."))=

#+begin_src emacs-lisp
  (defmacro :bind (key &rest body)
    (declare (indent defun))
    (pcase key
      ;; kbd string resolving symbol
      ((and k (pred symbolp) (pred boundp) (guard (stringp (eval key))))
       `(global-set-key (kbd ,(eval key)) ,(eval `(:command ,@body))))
      ;; partial mode symbol
      ((pred symbolp)
       (let ((mode (intern (format "%s-map" key)))
             (key (eval (car body)))
             (body (eval `(:command ,@(cdr body)))))
         `(define-key ,mode (kbd ,key) ,body)))
      ;; global binding
      (_ `(global-set-key (kbd ,key) ,(eval `(:command ,@body))))))
#+end_src

* global keybinds
** default hydra
Open the default hydra.

#+begin_src emacs-lisp
  (:bind "<f12>" (hera-start 'hydra-default/body))
#+end_src

** major mode hydra
Open the current major-mode hydra if it exists, or the default hydra.

#+begin_src emacs-lisp
  (:bind "<f13>" my/hydra-dwim)
#+end_src

** org capture
Activate org capture.

#+begin_src emacs-lisp
  (:bind "C-c c" org-capture)
#+end_src

** magit status
Activate magit's git status.

#+begin_src emacs-lisp
  (:bind "C-x g" magit-status)
#+end_src

** treemacs
Toggle the file-browser sidebar.

#+begin_src emacs-lisp
  (:bind "M-<f12>" treemacs-dwim)
  (:bind "S-M-<f12>" (delete-window (treemacs-get-local-window)))

  (:after treemacs
    (:bind treemacs-mode "f" treemacs-toggle-autopeek)
    (:bind treemacs-mode "C-p"
      (call-interactively 'treemacs-previous-line)
      (when treemacs-autopeek-mode
	(run-at-time "0.0 sec" nil 'call-interactively 'treemacs-peek)))
    (:bind treemacs-mode "C-n"
      (call-interactively 'treemacs-next-line)
      (when treemacs-autopeek-mode
	(run-at-time "0.0 sec" nil 'call-interactively 'treemacs-peek))))
#+end_src

** meta n & p
Quickly navigate buffer blocks/paragraphs.

#+begin_src emacs-lisp
  (:bind "M-p" backward-paragraph)
  (:bind "M-n" forward-paragraph)
#+end_src

** toggle contextual help
Toggle whether help buffers auto-update.

#+begin_src emacs-lisp
  (:bind "C-c h" toggle-context-help)
#+end_src

* aesthetics
** vertical border
Make the border between windows visible.

#+begin_src emacs-lisp
  (set-face-foreground 'vertical-border "gray")
#+end_src

** blend in the fringes
Hide the default buffer margins.

#+begin_src emacs-lisp
  (set-face-attribute 'fringe nil :background nil)
#+end_src

** column number
Show column number in addition to line number.

#+begin_src emacs-lisp
  (column-number-mode 1)
#+end_src

** doom modeline
Use [[https://github.com/seagle0128/doom-modeline][doom-modeline]] to ornament the modeline.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :config
    (doom-modeline-def-modeline
     'my-modeline

     '(bar workspace-name window-number modals matches buffer-info remote-host selection-info)
     '(objed-state misc-info buffer-position major-mode process vcs checker))

    (doom-modeline-mode 1)
    (setq doom-modeline-height 35)
    (setq doom-modeline-bar-width 5)
    :init
    (defun setup-custom-doom-modeline ()
      (doom-modeline-set-modeline 'my-modeline 'default))
    (:hook doom-modeline-mode 'setup-custom-doom-modeline))
#+end_src

* core settings
** autosaves
Periodically save a copy of open files.

*** autosave every file buffer
#+begin_src emacs-lisp
  (setq auto-save-default t)
#+end_src

*** save every 20 secs or 20 keystrokes
#+begin_src emacs-lisp
  (setq auto-save-timeout 20
        auto-save-interval 20)
#+end_src

*** keep autosaves in a single place
#+begin_src emacs-lisp
  (unless (file-exists-p my/autosaves-directory)
      (make-directory my/autosaves-directory))

  (setq auto-save-file-name-transforms
        `((".*" ,my/autosaves-directory t)))
#+end_src

** backups
Backups are created everytime a buffer is manually saved.

*** backup every save
#+begin_src emacs-lisp
  (use-package backup-each-save
    :config (:hook after-save backup-each-save))
#+end_src

*** keep 10 backups
#+begin_src emacs-lisp
  (setq kept-new-versions 10)
#+end_src

*** delete old backups
#+begin_src emacs-lisp
  (setq delete-old-versions t)
#+end_src

*** copy files to avoid various problems
#+begin_src emacs-lisp
  (setq backup-by-copying t)
#+end_src

*** backup files even if version controlled
#+begin_src emacs-lisp
  (setq vc-make-backup-files t)
#+end_src

*** keep backups in a single place
#+begin_src emacs-lisp
  (unless (file-exists-p my/backups-directory)
    (make-directory my/backups-directory))

  (setq backup-directory-alist
        `((".*" . ,my/backups-directory)))

  (setq make-backup-files t)
#+end_src

** cursor
*** box style
#+begin_src emacs-lisp
  (setq-default cursor-type 'box)
#+end_src

*** blinking
#+begin_src emacs-lisp
  (blink-cursor-mode 1)
#+end_src

** disable
Disable various UI and other features for a more minimal
experience.

*** menubar
#+begin_src emacs-lisp
  (menu-bar-mode -1)
#+end_src

*** toolbar
#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src

*** scrollbar
#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src

*** startup message
#+begin_src emacs-lisp
  (setq inhibit-startup-message t
        initial-scratch-message nil)
#+end_src

*** customizations file
Disable the customizations file so there's no temptation to use the
customization interface.

#+begin_src emacs-lisp
  (setq custom-file (make-temp-file ""))
#+end_src

** editing
*** use spaces
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

*** visual fill-column
#+begin_src emacs-lisp
  (use-package visual-fill-column
    :config
    (global-visual-fill-column-mode))
#+end_src

*** wrap lines at 79 characters
#+begin_src emacs-lisp
  (setq-default fill-column 79)
#+end_src

*** autowrap in text-mode
#+begin_src emacs-lisp
  (:hook text-mode 'turn-on-auto-fill)
#+end_src

*** ssh for tramp
Default method for transferring files with Tramp.

#+begin_src emacs-lisp
  (setq tramp-default-method "ssh")
#+end_src

** minor-modes
*** whitespace-mode
Visually display trailing whitespace

#+begin_src emacs-lisp
  (use-package whitespace
    :custom
    (whitespace-style
     '(face tabs newline trailing tab-mark space-before-tab space-after-tab))
    :config
    (global-whitespace-mode 1))
#+end_src

*** prettify-symbols-mode
Replace various symbols with nice looking unicode glyphs.

#+begin_src emacs-lisp
  (global-prettify-symbols-mode 1)
#+end_src

*** electric-pair-mode
Automatically insert matching close-brackets for any open bracket.

#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src

*** rainbow-delimeters-mode
Color parenthesis based on their depth, using the golden ratio (because why
not).

#+begin_src emacs-lisp
  (require 'color)
  (defun gen-col-list (length s v &optional hval)
    (cl-flet ( (random-float () (/ (random 10000000000) 10000000000.0))
            (mod-float (f) (- f (ffloor f))) )
      (unless hval
        (setq hval (random-float)))
      (let ((golden-ratio-conjugate (/ (- (sqrt 5) 1) 2))
            (h hval)
            (current length)
            (ret-list '()))
        (while (> current 0)
          (setq ret-list
                (append ret-list
                        (list (apply 'color-rgb-to-hex (color-hsl-to-rgb h s v)))))
          (setq h (mod-float (+ h golden-ratio-conjugate)))
          (setq current (- current 1)))
        ret-list)))

  (defun set-random-rainbow-colors (s l &optional h)
    ;; Output into message buffer in case you get a scheme you REALLY like.
    ;; (message "set-random-rainbow-colors %s" (list s l h))
    (interactive)
    (rainbow-delimiters-mode t)

    ;; Show mismatched braces in bright red.
    (set-face-background 'rainbow-delimiters-unmatched-face "red")

    ;; Rainbow delimiters based on golden ratio
    (let ( (colors (gen-col-list 9 s l h))
           (i 1) )
      (let ( (length (length colors)) )
        ;;(message (concat "i " (number-to-string i) " length " (number-to-string length)))
        (while (<= i length)
          (let ( (rainbow-var-name (concat "rainbow-delimiters-depth-" (number-to-string i) "-face"))
                 (col (nth i colors)) )
            ;; (message (concat rainbow-var-name " => " col))
            (set-face-foreground (intern rainbow-var-name) col))
          (setq i (+ i 1))))))

  (use-package rainbow-delimiters :commands rainbow-delimiters-mode :hook ...
    :init
    (setq rainbow-delimiters-max-face-count 16)
    (set-random-rainbow-colors 0.6 0.7 0.5)
    (:hook prog-mode 'rainbow-delimiters-mode))
#+end_src

*** show-paren-mode
Highlight the matching open or closing bracket.

#+begin_src emacs-lisp
  (require 'paren)
  (show-paren-mode 1)
  (setq show-paren-delay 0)
  (:after xresources
    (set-face-foreground 'show-paren-match (theme-color 'green))
    (set-face-foreground 'show-paren-mismatch "#f00")
    (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
    (set-face-attribute 'show-paren-mismatch nil :weight 'extra-bold))
#+end_src

*** which-key-mode
Show possible followups after pressing a key prefix.

#+begin_src emacs-lisp
  (use-package which-key
    :custom
    ;; sort single chars alphabetically P p Q q
    (which-key-sort-order 'which-key-key-order-alpha)
    (which-key-idle-delay 0.4)
    :config
    (which-key-mode))
#+end_src

*** company-mode
Show popup autocompletion.

#+begin_src emacs-lisp
  (use-package company
    :config
    (global-company-mode))
#+end_src

** shorten prompts
Shorten yes/no prompts to one letter.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** zoom
Adjust font size in buffers or globally.

#+begin_src emacs-lisp
  (use-package zoom-frm
    :straight (zoom-frm :type git
                        :host github
                        :repo "emacsmirror/emacswiki.org"
                        :files ("zoom-frm.el"))
    :config
    (dotimes (i my/default-zoom-level) (zoom-frm-in)))
#+end_src

** cache
This speeds up help:unicode-fonts-setup after first run.

#+begin_src emacs-lisp
  (use-package persistent-soft)
#+end_src

** eval depth
Avoid elision (...) in messages.

#+begin_src emacs-lisp
  (setq print-level 100
        print-length 9999
        eval-expression-print-level 100
        eval-expression-print-length 9999)
#+end_src

** debug on error
Show tracebacks when errors happen.

#+begin_src emacs-lisp
  (setq debug-on-error t)
#+end_src

* direnv
[[https://github.com/wbolster/emacs-direnv][emacs-direnv]] connects emacs to [[https://direnv.net/][direnv]] to obtain directory-specific environment
variables.

#+begin_src emacs-lisp
  (use-package direnv
   :config
   (direnv-mode))
#+end_src
* helpful
Alternative to the built-in Emacs help that provides much more contextual
information.

#+begin_src emacs-lisp
  (use-package helpful
      :straight (helpful :type git :host github :repo "Wilfred/helpful")
      :bind (("C-h s" . #'helpful-symbol)
             ("C-h c" . #'helpful-command)
             ("C-h f" . #'helpful-function)
             ("C-h v" . #'helpful-variable)
             ("C-h k" . #'helpful-key)
             ("C-h m" . #'helpful-mode)
             ("C-h C-h" . #'helpful-at-point)))
#+end_src

** contextual help
*** toggle-context-help
#+begin_src emacs-lisp
  (defun toggle-context-help ()
    "Turn on or off the context help.
  Note that if ON and you hide the help buffer then you need to
  manually reshow it. A double toggle will make it reappear"
    (interactive)
    (with-current-buffer (help-buffer)
      (unless (local-variable-p 'context-help)
        (set (make-local-variable 'context-help) t))
      (if (setq context-help (not context-help))
          (progn
             (if (not (get-buffer-window (help-buffer)))
                 (display-buffer (help-buffer)))))
      (message "Context help %s" (if context-help "ON" "OFF"))))
#+end_src

*** context-help
#+begin_src emacs-lisp
  (defun context-help ()
    "Display function or variable at point in *Help* buffer if visible.
  Default behaviour can be turned off by setting the buffer local
  context-help to false"
    (interactive)
    (let ((rgr-symbol (symbol-at-point))) ; symbol-at-point http://www.emacswiki.org/cgi-bin/wiki/thingatpt%2B.el
      (with-current-buffer (help-buffer)
       (unless (local-variable-p 'context-help)
         (set (make-local-variable 'context-help) t))
       (if (and context-help (get-buffer-window (help-buffer))
           rgr-symbol)
         (if (fboundp  rgr-symbol)
             (describe-function rgr-symbol)
           (if (boundp  rgr-symbol) (describe-variable rgr-symbol)))))))
#+end_src

*** advise symbol eldoc
#+begin_src emacs-lisp
  (defadvice eldoc-print-current-symbol-info
    (around eldoc-show-c-tag activate)
    (cond
          ((eq major-mode 'emacs-lisp-mode) (context-help) ad-do-it)
          ((eq major-mode 'lisp-interaction-mode) (context-help) ad-do-it)
          ((eq major-mode 'apropos-mode) (context-help) ad-do-it)
          (t ad-do-it)))
#+end_src

* projectile
[[https://github.com/bbatsov/projectile][Projectile]] offers a number of features related to project interaction. It can
track the root directories and sibling files of files you edit
automatically. Combined with Helm, you can very quickly navigate related files.

Projectile's default prefix is =C-c p=

#+begin_src emacs-lisp
  (use-package projectile
    :config
    (setq projectile-enable-caching t)
    (projectile-mode t))
#+end_src

** project discovery
#+begin_src emacs-lisp
  (setq projectile-project-root-files-bottom-up
        '(".git" ".hg" "README.md" "README.org" "README")
        projectile-project-search-path my/projects-directory
        projectile-sort-order 'access-time)
  (projectile-discover-projects-in-directory my/projects-directory)
  (projectile-discover-projects-in-directory my/sources-directory)
#+end_src

* helm
Menu and selection framework for finding files, switching buffers, running
grep, etc.

#+begin_src emacs-lisp
  (use-package helm
    :config
    (helm-mode 1)
    (require 'helm-config)
    (:bind "M-x" helm-M-x)
    (:bind "C-x C-f" helm-find-files)
    (:bind "C-x b" helm-mini)
    (:bind "C-c y" helm-show-kill-ring)
    (:bind "C-x C-r" helm-recentf))
#+end_src
** ace jump
Quickly jump to any candidate with a short letter combo.

#+begin_src emacs-lisp
  (use-package ace-jump-helm-line
    :config
    (:bind helm "C-;" ace-jump-helm-line))
#+end_src

** helm-ag
#+begin_src emacs-lisp
  (use-package helm-ag)
#+end_src

** helm-descbinds
Use (=C-h b= / =kbd-helm-descbinds=) to inspect current bindings with Helm.

#+begin_src emacs-lisp
  (use-package helm-descbinds
    :commands helm-descbinds
    :config
    (:bind "C-h b" helm-descbinds))
#+end_src

** helm-flyspell
Check and correct spelling for some modes.

#+begin_src emacs-lisp
  (use-package helm-flyspell
    :commands helm-flyspell-correct
    :config
    (:bind " M-SPC" helm-flyspell-correct)
    (:hook org-mode flyspell-mode)
    (:hook text-mode flyspell-mode)
    (:hook fundamental-mode flyspell-mode))
#+end_src

** helm-projectile
Make Projectile use Helm for selections.

#+begin_src emacs-lisp
  (use-package helm-projectile
      :config
      (projectile-cleanup-known-projects)
      (setq projectile-completion-system 'helm))
#+end_src

*** projectile-readme
Open readme of the current project.

#+begin_src emacs-lisp
  (defun projectile-readme ()
      (interactive)
      (let ((file-name (-find (lambda (f) (s-matches? "^readme" f))
                              (projectile-current-project-files))))
        (find-file (concat (projectile-project-root) "/" file-name))))
#+end_src

*** hydra-projectile-dwim
Open the projectile hydra when in a project. Otherwise, select a project.

#+begin_src emacs-lisp
  (defun hydra-projectile-dwim ()
      (interactive)
      (if (string= "-" (projectile-project-name))
          (helm-projectile)
        (hydra-projectile/body)))
#+end_src

** auto full frame
Make Helm always full height.

#+begin_src emacs-lisp
  (defvar helm-full-frame-threshold 0.75)

  (when window-system
    (defun helm-full-frame-hook ()
    (let ((threshold (* helm-full-frame-threshold (x-display-pixel-height))))
      (setq helm-full-frame (< (frame-height) threshold))))

    (:hook helm-before-initialize 'helm-full-frame-hook))
#+end_src

* treemacs
Browse files in a sidebar.

#+begin_src emacs-lisp
  (use-package treemacs
    :config
    (setq treemacs-width 25
          treemacs-follow-mode -1
          treemacs-tag-follow-mode -1
          treemacs-is-never-other-window t
          treemacs-follow-after-init t
          treemacs-icon-open-png   (propertize "‚äñ " 'face 'treemacs-directory-face)
          treemacs-icon-closed-png (propertize "‚äï " 'face 'treemacs-directory-face))
    (define-key treemacs-mode-map [mouse-1]
      #'treemacs-single-click-expand-action))

  (use-package treemacs-projectile)
  (use-package treemacs-magit)
#+end_src

** toggle-autopeek
#+begin_src emacs-lisp
  (setq treemacs-autopeek-mode nil)

  (defun treemacs-toggle-autopeek ()
    (interactive)
    (if treemacs-autopeek-mode
        (progn
          (setq treemacs-autopeek-mode nil)
          (message "Treemacs autopeek: OFF"))
      (setq treemacs-autopeek-mode t)
      (message "Treemacs autopeek: ON")))
#+end_src

** treemacs-dwim
#+begin_src emacs-lisp
  (defun treemacs-dwim ()
    (interactive)
    (pcase (treemacs-current-visibility)
      ((or 'none 'exists)
       (setq treemacs-previous-window (list (selected-frame) (selected-window)))
       (treemacs))
      ((and 'visible (guard (not (s-contains? "Treemacs-Scoped"
                                              (buffer-name (current-buffer))))))
       (setq treemacs-previous-window (list (selected-frame) (selected-window)))
       (treemacs-select-window))
      (_ (select-frame (car treemacs-previous-window))(select-window (cadr treemacs-previous-window)))))t
#+end_src

* yasnippet
Expand interactive snippets.

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (setq yas-snippet-dirs `(,my/yas-directory))
    (yas-global-mode 1))
#+end_src

* magit
The best git frontend there is.

#+begin_src emacs-lisp
  (use-package magit)
#+end_src

* org-mode
A souped up markup with tasking, scheduling and aggregation features.

** straight.el fixes
Fix some issues with straight.el and org until [[https://github.com/raxod502/straight.el#installing-org-with-straightel][that is resolved]].

*** fix-org-git-version
#+begin_src emacs-lisp
  (defun fix-org-git-version ()
    "The Git version of org-mode.
    Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (git-run "describe"
                "--match=release\*"
                "--abbrev=6"
                "HEAD"))))
#+end_src

*** fix-org-release
#+begin_src emacs-lisp
  (defun fix-org-release ()
    "The release version of org-mode.
    Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (string-remove-prefix
        "release_"
        (git-run "describe"
                 "--match=release\*"
                 "--abbrev=0"
                 "HEAD")))))
#+end_src

** installation
#+begin_src emacs-lisp
  (use-package org
    :config
    ;; these depend on the 'straight.el fixes' above
    (defalias #'org-git-version #'fix-org-git-version)
    (defalias #'org-release #'fix-org-release)
    (require 'org-habit)
    (require 'org-indent)
    (add-to-list 'org-modules 'org-habit t)
    (require 'org-capture)
    (require 'org-tempo))
#+end_src

** look
*** theme customizations
#+begin_src emacs-lisp
  (when window-system
    (use-package org-beautify-theme
      :after (org)
      :config
      (setq org-fontify-whole-heading-line t)
      (setq org-fontify-quote-and-verse-blocks t)
      (setq org-hide-emphasis-markers t)))
#+end_src

*** pretty symbols
Add a hook to set the pretty symbols alist.

#+begin_src emacs-lisp
  (setq my/org-pretty-symbols nil)
  (:hook org-mode
    (setq-local prettify-symbols-alist my/org-pretty-symbols))
#+end_src
*** indent by header level
Hide the heading asterisks. Instead indent headings based on depth.

#+begin_src emacs-lisp
  (:hook org-mode 'org-indent-mode)
#+end_src

*** pretty heading bullets
Use nice unicode bullets instead of the default asterisks.

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    (:hook org-mode 'org-bullets-mode)
    :config
    (setq org-bullets-bullet-list '("‚óâ" "‚óã" "‚ú∏" "‚Ä¢")))
#+end_src

*** pretty priority cookies
Instead of the default =[#A]= and =[#C]= priority cookies, use little unicode arrows to
indicate high and low priority. =[#B]=, which is the same as no priority, is shown as
normal.

#+begin_src emacs-lisp
  (:push my/org-pretty-symbols
    '("[#A]" . "‚áë")
    '("[#C]" . "‚áì"))
#+end_src

#+begin_src emacs-lisp
  ;; only show priority cookie symbols on headings.
  (defun nougat/org-pretty-compose-p (start end match)
    (if (or (string= match "[#A]") (string= match "[#C]"))
        ;; prettify asterisks in headings
        (org-match-line org-outline-regexp-bol)
      ;; else rely on the default function
      (funcall #'prettify-symbols-default-compose-p start end match)))


  (:hook org-mode (setq-local prettify-symbols-compose-predicate
                              #'nougat/org-pretty-compose-p))
#+end_src

*** pretty heading ellipsis
Show a little arrow for collapsed headings.

#+begin_src emacs-lisp
  (:after org
    (setq org-ellipsis " ‚ñø"))
#+end_src

*** prettify source blocks
#+begin_src emacs-lisp
  (:push my/org-pretty-symbols
    '("#+begin_src" . ">>")
    '("#+end_src" . "¬∑"))
#+end_src
*** dynamic tag position
#+begin_src emacs-lisp
  (defun org-realign-tags ()
    (interactive)
    (setq org-tags-column (- 0 (window-width)))
    (org-align-tags t))

  ;; (:hook window-configuration-change 'org-realign-tags)
#+end_src

** feel
*** show all headings on startup
#+begin_src emacs-lisp
  (setq org-startup-folded 'content)
#+end_src

*** don't fold blocks on open
#+begin_src emacs-lisp
  (setq org-hide-block-startup nil)
#+end_src

*** auto-fill paragraphs
#+begin_src emacs-lisp
  (:hook org-mode 'turn-on-auto-fill)
#+end_src

*** resepect content on insert
Don't split existing entries when inserting a new heading.

#+begin_src emacs-lisp
  (setq org-insert-heading-respect-content nil)
#+end_src

*** use helpful for help links
#+begin_src emacs-lisp
  (advice-add 'org-link--open-help :override
              (lambda (path) (helpful-symbol (intern path))))
#+end_src
*** ensure one-line between headers
When you save, this section will ensure that there is a one-line space between each
heading. This helps with the background color of code-blocks not showing up on folded
headings.

#+begin_src emacs-lisp
  ;; (defun my/org-no-line-before-headlines ()
  ;;   (beginning-of-buffer)
  ;;   (while (re-search-forward "\n\\{3,\\}\\*" nil t)
  ;;     (replace-match "\n\n*")))

  ;; (defun my/org-one-line-after-headlines ()
  ;;   (beginning-of-buffer)
  ;;   (while (re-search-forward "^\\*+.*\n\\{2,\\}" nil t)
  ;;     (outline-previous-heading)
  ;;     (end-of-line)
  ;;     (forward-char)
  ;;     (while (looking-at "^[:space:]*$")
  ;;       (kill-line))))

  ;; (defun my/org-trim-headlines ()
  ;;   (let ((markers nil))
  ;;     (org-element-map (org-element-parse-buffer) '(headline)
  ;;       (lambda (paragraph)
  ;;         (let ((contents-end (org-element-property :contents-end paragraph))
  ;;               (post-blank (org-element-property :post-blank paragraph))
  ;;               (marker (make-marker)))
  ;;           (goto-char contents-end)
  ;;           (unless (eq 0 post-blank)
  ;;             (set-marker marker contents-end)
  ;;             (setq markers (append markers (list (cons marker post-blank))))))))
  ;;     (--each markers (save-excursion
  ;;                       (goto-char (car it))
  ;;                       (kill-line (- (cdr it) 1))))))

  ;; (defun my/org-element-type-at-point ()
  ;;   (car (org-element-at-point)))

  ;; (defun my/org-point-at-headline ()
  ;;   (let* ((element-type (my/org-element-type-at-point)))
  ;;     (eq 'headline element-type)))

  ;; (defun my/org-mark-elements (data types marker-prop &rest props)
  ;;   (let ((markers nil))
  ;;     (org-element-map data types
  ;;       (lambda (element)
  ;;         (let* ((marker (make-marker))
  ;;                (marker-pos (org-element-property marker-prop element))
  ;;                (prop-map (make-hash-table)))
  ;;           (when marker-pos
  ;;             (set-marker marker marker-pos)
  ;;             (--each props (map-put! prop-map it (org-element-property it element)))
  ;;             (setq markers (append markers (list (cons marker prop-map))))))))

  ;;     markers))

  ;; (defun my/org-visit-markers (markers)
  ;;   (--each markers
  ;;     (goto-char (car it))
  ;;     (sit-for 1)))

  ;; (defun my/org-visit-elements (types &optional data)
  ;;   (setq data (or data (org-element-parse-buffer)))
  ;;   (my/org-visit-markers (my/org-mark-elements data types :begin)))

  ;; (defun my/org-trim-headlines ()
  ;;   (save-excursion
  ;;     (--each (my/org-mark-elements (org-element-parse-buffer) '(headline) :begin :pre-blank)
  ;;       (let* ((prop-map (cdr it))
  ;;              (pre-blank (map-elt prop-map :pre-blank)))
  ;;         (when (> pre-blank 1)
  ;;           (goto-char (car it))
  ;;           (end-of-line)
  ;;           (forward-char)
  ;;           (sit-for 1)
  ;;           (kill-line (max 0 pre-blank)))))))

  ;; (defun my/org-trim-paragraphs ()
  ;;   (save-excursion
  ;;     (--each (my/org-mark-elements (org-element-parse-buffer) '(paragraph section src-block) :contents-end :post-blank)
  ;;       (let* ((prop-map (cdr it))
  ;;              (post-blank (map-elt prop-map :post-blank)))
  ;;         (if (> post-blank 1)
  ;;             (progn (goto-char (car it))
  ;;              (sit-for 1)
  ;;              (kill-line (max 0 (- post-blank 1))))
  ;;           (when (eq 0 post-blank)
  ;;             (goto-char (car it))
  ;;             (end-of-line)
  ;;             (forward-char)
  ;;             (open-line 1)))))))

  ;; (defun my/org-cleanup ()
  ;;   (interactive)
  ;;   (my/org-trim-headlines)
  ;;   (my/org-trim-paragraphs))


  ;; (:after org
  ;;   (:hook org-mode
  ;;     (:hook before-save :local
  ;;       (my/org-cleanup))))
#+end_src

** todo keywords
*** boilerplate
**** make-state-model
#+begin_src emacs-lisp
  (defun todo-make-state-model (name key props)
    (append (list :name name :key key) props))
#+end_src
**** parse-state-data
#+begin_src emacs-lisp
  (defun todo-parse-state-data (state-data)
    (-let* (((name second &rest) state-data)
            ((key props) (if (stringp second)
                             (list second (cddr state-data))
                           (list nil (cdr state-data)))))
      (todo-make-state-model name key props)))
#+end_src
**** make-sequence-mode
#+begin_src emacs-lisp
  (defun todo-make-sequence-model (states)
    (mapcar 'todo-parse-state-data states))
#+end_src
**** parse-sequences-data
#+begin_src emacs-lisp
  (defun todo-parse-sequences-data (sequences-data)
    (mapcar 'todo-make-sequence-model sequences-data))
#+end_src
**** todo-keyword-name
#+begin_src emacs-lisp
  (defun todo-keyword-name (name key)
    (if key (format "%s(%s)" name key) name))
#+end_src
**** keyword-name-forstate
#+begin_src emacs-lisp
  (defun todo-keyword-name-for-state (state)
    (todo-keyword-name (plist-get state :name)
                       (plist-get state :key)))
#+end_src
**** is-done-state
#+begin_src emacs-lisp
  (defun todo-is-done-state (state)
    (equal t (plist-get state :done-state)))
#+end_src
**** is-not-done-state
#+begin_src emacs-lisp
  (defun todo-is-not-done-state (state)
    (equal nil (plist-get state :done-state)))
#+end_src
**** org-sequence
#+begin_src emacs-lisp
  (defun todo-org-sequence (states)
    (let ((active (seq-filter 'todo-is-not-done-state states))
          (inactive (seq-filter 'todo-is-done-state states)))
      (append '(sequence)
              (mapcar 'todo-keyword-name-for-state active)
              '("|")
              (mapcar 'todo-keyword-name-for-state inactive))))
#+end_src
**** org-todo-keywords
#+begin_src emacs-lisp
  (defun todo-org-todo-keywords (sequences)
    (mapcar 'todo-org-sequence (todo-parse-sequences-data sequences)))
  ;; (todo-org-todo-keywords todo-keywords)
#+end_src
**** org-todo-keyword-faces
#+begin_src emacs-lisp
  (defun todo-org-todo-keyword-faces (sequences)
    (cl-loop for sequence in (todo-parse-sequences-data sequences)
             append (cl-loop for state in sequence
                             for name = (plist-get state :name)
                             for face = (plist-get state :face)
                             collect (cons name face))))
  ;; (todo-org-todo-keyword-faces todo-keywords)
#+end_src
**** prettify-symbols-alist
#+begin_src emacs-lisp
  (defun todo-prettify-symbols-alist (sequences)
    (cl-loop for sequence in (todo-parse-sequences-data sequences)
             append (cl-loop for state in sequence
                             for name = (plist-get state :name)
                             for icon = (plist-get state :icon)
                             collect (cons name icon))))
  ;; (todo-prettify-symbols-alist todo-keywords)
#+end_src
**** finalize-agenda-for-state
#+begin_src emacs-lisp
  (defun todo-finalize-agenda-for-state (state)
    (-let (((&plist :name :icon :face) state))
      (beginning-of-buffer)
      (while (search-forward name nil 1)
        (let* ((line-props (text-properties-at (point)))
               (line-props (org-plist-delete line-props 'face)))
          (call-interactively 'set-mark-command)
          (search-backward name)
          (call-interactively 'kill-region)
          (let ((symbol-pos (point)))
            (insert icon)
            (beginning-of-line)
            (let ((start (point))
                  (end (progn (end-of-line) (point))))
              (add-text-properties start end line-props)
              (add-face-text-property symbol-pos (+ 1 symbol-pos) face))))))
    (beginning-of-buffer)
    (replace-regexp "[[:space:]]+[=]+" ""))
#+end_src

*** keywords
#+begin_src emacs-lisp
  (setq todo-keywords
        ;; normal workflow
        '((("DOING" "d" :icon "üèÉ" :face org-doing-face)
           ("TODO" "t" :icon "‚ñ°‚ÄÑ" :face org-todo-face)
           ("DONE" "D" :icon "‚úì‚ÄÑ" :face org-done-face :done-state t))
          ;; auxillary states
          (("SOON" "s" :icon "‚ùó‚ÄÄ" :face org-soon-face)
           ("SOMEDAY" "S" :icon "üõå" :face org-doing-face)))
        org-todo-keywords (todo-org-todo-keywords todo-keywords)
        org-todo-keyword-faces (todo-org-todo-keyword-faces todo-keywords))

  (--map (:push my/org-pretty-symbols it)
         (todo-prettify-symbols-alist todo-keywords))
#+end_src

*** org agenda finalization
#+begin_src emacs-lisp
  (setq my/todo-sequences-data (todo-parse-sequences-data todo-keywords))
  (:hook org-agenda-finalize
    (--each my/todo-sequences-data
      (-each it 'todo-finalize-agenda-for-state)))
#+end_src
*** sorting
#+begin_src emacs-lisp
  (defun my/todo-sort (a b)
    (let* ((a-state (get-text-property 0 'todo-state a))
           (b-state (get-text-property 0 'todo-state b))
           (a-index (-elem-index a-state todo-keyword-order))
           (b-index (-elem-index b-state todo-keyword-order)))
      (pcase (- b-index a-index)
        ((and v (guard (< 0 v))) 1)
        ((and v (guard (> 0 v))) -1)
        (default nil))))

  (setq org-agenda-cmp-user-defined 'my/todo-sort
        todo-keyword-order '("DOING" "SOON" "TODO" "SOMEDAY" "DONE"))
#+end_src

** org-capture
*** org-directory
help:org-directory is the default location for captures.
#+begin_src emacs-lisp
  (setq org-directory my/org-directory)
#+end_src
*** set default notes file
#+begin_src emacs-lisp
  (setq org-default-notes-file my/notes-file-name)
#+end_src
*** automatically visit new capture
#+begin_src emacs-lisp
  (:after org
    (:push org-capture-after-finalize-hook 'org-capture-goto-last-stored))
#+end_src
*** capture templates
#+begin_src emacs-lisp
#+end_src

** org-babel
*** babel languages
**** ob-csharp
#+begin_src emacs-lisp
  (use-package ob-csharp
    :straight (ob-csharp :type git
                         :host github
                         :repo "thomas-villagers/ob-csharp"
                         :files ("src/ob-csharp.el"))
    :config
    (:push org-babel-load-languages '(csharp . t)))
#+end_src
**** ob-fsharp
#+begin_src emacs-lisp
  (use-package ob-fsharp
    :straight (ob-fsharp :type git
                         :host github
                         :repo "zweifisch/ob-fsharp"
                         :files ("ob-fsharp.el"))
    :config
    (:push org-babel-load-languages '(fsharp . t)))
#+end_src
*** enable languages
#+begin_src emacs-lisp
  (setq org-babel-load-languages
        '((shell . t)
          (emacs-lisp . t)
          (python . t)
          (js . t)
          (csharp . t)
          (fsharp . t)))
#+end_src

*** default header args
#+begin_src emacs-lisp
  (:after org
    (setq org-babel-default-header-args
          '((:session . "none")
            (:results . "replace")
            (:exports . "code")
            (:cache . "no")
            (:noweb . "no")
            (:hlines . "no")
            (:tangle . "no"))))
#+end_src

*** security
Disable prompts for evaluating org-mode links.
#+begin_src emacs-lisp
  (progn
    (setq org-confirm-babel-evaluate nil)
    (setq org-confirm-elisp-link-function nil)
    (setq org-confirm-shell-link-function nil)
    (setq safe-local-variable-values '((org-confirm-elisp-link-function . nil))))
#+end_src
*** install babel handlers
#+begin_src emacs-lisp
  (:hook after-init
    (org-babel-do-load-languages 'org-babel-load-languages
                                 org-babel-load-languages))
#+end_src

** helm-org
#+begin_src emacs-lisp
  (use-package helm-org)
#+end_src
** helm-org-rifle
Quickly search through the current org buffer.

#+begin_src emacs-lisp
  (use-package helm-org-rifle)
#+end_src
** org-projectile
#+begin_src emacs-lisp
  (use-package org-projectile
    :config
    (org-projectile-per-project)
    (setq org-projectile-per-project-filepath "notes.org")
    (:push org-capture-templates
      (org-projectile-project-todo-entry
       :capture-character "l"
       :capture-heading "Linked Project TODO"))
    (:push org-capture-templates
      (org-projectile-project-todo-entry
       :capture-character "p")))

#+end_src

*** org-projectile-helm
#+begin_src emacs-lisp
  (use-package org-projectile-helm
    :after org-projectile
    :bind (("C-c n p" . org-projectile-helm-template-or-project)))
#+end_src

** super-agenda
Provides better organization of the agenda view.

*** narrow agenda by header
Hitting =C-<return>= on a header will narrow the agenda to that file.

#+begin_src emacs-lisp
  (setq my/org-agenda-nested nil)
  (define-key org-agenda-mode-map (kbd "C-<return>")
    (lambda () (interactive)
      (unless my/org-agenda-nested
        (setq my/org-agenda-nested t)
        (with-current-buffer (marker-buffer (get-text-property (point) 'org-marker))
          (org-agenda nil "a" "<")))))

  ;; pop back to main agenda view, or quit
  (defun my/org-agenda-quit ()
    (interactive)
    (org-agenda-quit)
    (when my/org-agenda-nested
      (setq my/org-agenda-nested nil)
      (org-agenda nil "a")))

  (define-key org-agenda-mode-map (kbd "q") 'my/org-agenda-quit)
#+end_src
*** transform agenda items
Clean up the item display, including the project and file names.

#+begin_src emacs-lisp
  (defun org-agenda-transformer (it)
    (-let* (((blank todo rest) (s-split-up-to
                                "[[:blank:]]+"
                                (substring-no-properties it) 2))
            (buffer-name (->> it
                              (get-text-property 0 'org-marker)
                              (marker-buffer)
                              (buffer-file-name)))
            (file-name (->> buffer-name f-filename))
            (project-name (->> buffer-name (f-parent) (f-base)))
            (text (s-collapse-whitespace
                   (format "  %s %s/%s: %s" todo project-name file-name rest))))
      (set-text-properties 0 (- (length text) 1) (text-properties-at 0 it) text)
      text))

  (defun org-agenda-schedule-transformer (it)
    (-let* (((_ _ _ rest) (s-split-up-to
                           "[[:blank:]]+"
                           (substring-no-properties it) 3))
            (todo (get-text-property 0 'todo-state it))
            (buffer-name (->> it
                              (get-text-property 0 'org-marker)
                              (marker-buffer)
                              (buffer-file-name)))
            (file-name (->> buffer-name f-filename))
            (project-name (->> buffer-name (f-parent) (f-base)))
            (text (s-collapse-whitespace
                   (format "  %s %s/%s: %s" todo project-name file-name rest))))
      (set-text-properties 0 (length text) (text-properties-at 0 it) text)
      text))
#+end_src

*** group items by project & filename
#+begin_src emacs-lisp
  (defun org-agenda-group-items (item)
    (-when-let* ((new-marker (make-marker))
                 (marker (or (get-text-property 0 'org-marker item)
                             (get-text-property 0 'org-hd-marker item)))
                 (file-path (->> marker marker-buffer buffer-file-name))
                 (file-name (f-filename file-path))
                 (directory (f-dirname file-path))
                 (directory-name (f-filename
                                  (or (projectile-root-bottom-up file-path) directory)))
                 (heading (s-replace "//" "/" (format "%s/%s" directory-name file-name))))
      (set-marker new-marker 1 (marker-buffer marker))
      (propertize heading 'org-marker new-marker 'org-hd-marker new-marker)))
#+end_src

*** agenda layout
#+begin_src emacs-lisp
  (defun get-agenda-commands ()
    '(("a" "agenda view"
       ((agenda "" ((org-agenda-overriding-header "")
                    (org-agenda-span 'day)
                    (org-super-agenda-groups
                     '((:name "Today"
                              :transformer (org-agenda-schedule-transformer it)
                              :scheduled today)
                       (:name "Overdue"
                              :transformer (org-agenda-schedule-transformer it)
                              :scheduled past)))))
        (alltodo "" ((org-agenda-overriding-header "")
                     (org-super-agenda-groups
                      '(;; (:name "Today" :time-grid t :date today :todo "TODAY" :scheduled today)
                        (:discard (:scheduled today :scheduled past))
                        (:name "Active" :todo "DOING" :transformer (org-agenda-transformer it))
                        (:name "Important" :tag "Important" :priority "A")
                        (:name "Some Day" :todo "SOMEDAY" :transformer (org-agenda-transformer it) :order 5)
                        (:name "Todo" :auto-map org-agenda-group-items :todo "TODO")))))
        ))))
#+end_src

** org-agenda
Aggregate tasks across multiple org files.

*** super agenda mode
Enhance the agenda with dynamic groups.

#+begin_src emacs-lisp
  (use-package org-super-agenda
    :config
    (setq org-agenda-custom-commands (get-agenda-commands))
    (org-super-agenda-mode))
#+end_src
*** don't format todo keywords
#+begin_src emacs-lisp
  (setq org-agenda-todo-keyword-format ""
        org-agenda-prefix-format '((todo . "  %(org-get-todo-state)")))
#+end_src

*** sorting strategy
#+begin_src emacs-lisp
  (setq org-agenda-sorting-strategy
        '((agenda habit-down time-up priority-down category-keep)
          (todo user-defined-down priority-down category-keep)
          (tags priority-down category-keep)
          (search category-keep)))
#+end_src

*** agenda files
Add files to agenda aggregation.

#+begin_src emacs-lisp
  (setq org-agenda-files (->> (append (f-glob (my/get-org-file "*/*.org"))
                                      (f-glob (my/get-project-directory "*/*.org")))
                              (-filter 'f-exists?)))
#+end_src
** org-journal
#+begin_src emacs-lisp
  (use-package org-journal
    :config
    (setq org-journal-dir (concat my/org-directory "journal"))
    (setq org-journal-file-type 'weekly)
    (setq org-journal-start-on-weekday 5))
#+end_src

** org-fragtog
Automatically preview LaTex fragments.

#+begin_src emacs-lisp
  (use-package org-fragtog
    :config
    (:hook org-mode 'org-fragtog-mode))
#+end_src

** linkmarks
Use org as the bookmark backend.

#+begin_src emacs-lisp
  (use-package linkmarks
    :straight (linkmarks :type git :host github :repo "dustinlacewell/linkmarks"))
#+end_src

** org-ql
#+begin_src emacs-lisp
  (use-package org-ql)
#+end_src

** helm-org-walk
#+begin_src emacs-lisp
  (use-package helm-org-walk
    :straight (helm-org-walk :type git :host github :repo "dustinlacewell/helm-org-walk"))
#+end_src
** org-ls
#+begin_src emacs-lisp
  (load-file (expand-file-name "~/src/org-ls/org-ls.el"))
#+end_src
** quiet file-local variables
#+begin_src emacs-lisp
  (setq safe-local-variable-values '((org-confirm-elisp-link-function . nil)))
#+end_src

* outshine
Collapse sections in various modes like elisp.

#+begin_src emacs-lisp
  (use-package outshine
    :init (defvar outline-minor-mode-prefix "\M-#")
    :config (setq outshine-use-speed-commands t)
    :hook ((emacs-lisp-mode . outshine-mode) (nix-mode . outshine-mode)))
#+end_src

* language support
** flycheck
Show syntax errors for programming languages.

#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

** elisp
*** macrostep
Interactively expand macros.

#+begin_src emacs-lisp
  (use-package macrostep
    :straight (macrostep :type git :host github :repo "joddie/macrostep")
    :config
    (:bind emacs-lisp-mode "C-c e" macrostep-expand))
#+end_src

*** lispy-mode
#+begin_src emacs-lisp
  (use-package lispy
    :init
    (:hook emacs-lisp-mode (lispy-mode 1))
    (:hook lisp-interaction-mode (lispy-mode 1))
    :config
    (:bind lispy-mode ":" self-insert-command)
    (:bind lispy-mode "[" lispy-open-square)
    (:bind lispy-mode "]" lispy-close-square))
#+end_src

** markdown-mode
All the internet uses it.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :config (setq markdown-command "multimarkdown"))
#+end_src

** python
*** elpy
#+begin_src emacs-lisp
  (use-package elpy)
#+end_src
*** jedi
[[https://github.com/tkf/emacs-jedi][Jedi]] is an auto-completion server for Python.

#+begin_src emacs-lisp

  (use-package jedi
    :init
    (progn
      (:hook python-mode jedi:setup)
      (setq jedi:complete-on-dot t)))
#+end_src

** javascript
**** js2-mode
#+begin_src emacs-lisp
  (use-package js2-mode
    :config
    (:push auto-mode-alist '("\\.js\\'" . js2-mode))
    (:hook js2-mode js2-imenu-extras-mode)
    (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
    (define-key js-mode-map (kbd "M-.") nil)
    (setq js2-include-node-externs t)
    (setq js2-include-browser-externs t))
#+end_src
**** xref-js2
#+begin_src emacs-lisp
  (use-package xref-js2
    :config
    (:hook js2-mode
      (:hook xref-backend-functions :local xref-js2-xref-backend)))
#+end_src
**** js2-refactor
#+begin_src emacs-lisp
  (use-package js2-refactor
    :config
    (:hook js2-mode js2-refactor-mode)
    (js2r-add-keybindings-with-prefix "C-c C-r"))
#+end_src
**** company-tern
#+begin_src emacs-lisp
  (use-package company-tern
    :config
    (setq tern-command '("npx" "tern"))
    (:push company-backends 'company-tern)
    (:hook js2-mode
      (tern-mode)
      (company-mode))

    ;; Disable completion keybindings, as we use xref-js2 instead
    (define-key tern-mode-keymap (kbd "M-.") nil)
    (define-key tern-mode-keymap (kbd "M-,") nil))
#+end_src

** typescript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :config
    (flycheck-add-mode 'typescript-tslint 'web-mode))
#+end_src
**** tide
#+begin_src emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (direnv-mode)
    (direnv-update-environment)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (setq tide-hl-identifier-idle-time 0.0)
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    (company-mode +1))

  (use-package tide
    :config
    (:hook before-save tide-format-before-save)
    (:hook typescript-mode setup-tide-mode)
    (:push auto-mode-alist '("\\.tsx\\'" . web-mode))
    (:hook web-mode
      (when (string-equal "tsx" (file-name-extension buffer-file-name))
        (setup-tide-mode)))

    (:hook web-mode
      (when (string-equal "tsx" (file-name-extension buffer-file-name))
        (setup-tide-mode)))

    (flycheck-add-mode 'typescript-tslint 'web-mode))

  (defun tide-cleanup-imports ()
    (interactive)
    (save-excursion
      (tide-organize-imports)
      (beginning-of-buffer)
      (while (search-forward-regexp "^import[[:space:]]+[[:alpha:]{},[:space:]]+\"" nil t)
        (embrace--insert ?\' (embrace--delete ?\" t)))
      (beginning-of-buffer)
      (when (search-forward-regexp "^import[[:space:]]+[[:alpha:]{},[:space:]]+\'[^[:alpha:]]" nil t)
        (beginning-of-line)
        (open-line 1))
      (progn
        (beginning-of-buffer)
        ;; search for first non-import line
        (while (or
                (string-match "\\(^import\\|^//\\)" (thing-at-point 'line t))
                (string-equal "\n" (thing-at-point 'line t)))
          (end-of-line)
          (forward-char))

        ;; delete all preceeding whitespace
        (while (progn (beginning-of-line)
                      (backward-char)
                      (beginning-of-line)
                      (string-equal "\n" (thing-at-point 'line t)))
          (kill-line))
        (end-of-line)
        (forward-char)
        (open-line 2))
      (tide-format)))
#+end_src

** nim
#+begin_src emacs-lisp
  (use-package nim-mode)
#+end_src

** yaml
#+begin_src emacs-lisp
  (use-package yaml-mode
    :config
    (:push auto-mode-alist '("\\.yml\\'" . yaml-mode)))
#+end_src

** web-mode
#+begin_src emacs-lisp
  (use-package prettier-js
    :config
    (setq prettier-js-args '("--tab-width" "4" "--trailing-comma" "all")))

  (use-package add-node-modules-path)

  (use-package json-mode
    :straight (json-mode :type git
                         :host github
                         :repo "kiennq/json-mode"
                         :branch "feat/jsonc-mode")
    :config
    (setf auto-mode-alist (assoc-delete-all "\\(?:\\(?:\\.\\(?:b\\(?:\\(?:abel\\|ower\\)rc\\)\\|json\\(?:ld\\)?\\)\\|composer\\.lock\\)\\'\\)" auto-mode-alist))
    (setf auto-mode-alist (assoc-delete-all "\\.json\\'" auto-mode-alist))
    (:push auto-mode-alist '("\\.json\\'" . jsonc-mode)))

  (defun org-babel-execute:jsonc (body params)
    "Execute a block of jsonc with org-babel."
    body)

  (defun org-babel-execute:json (body params)
    "Execute a block of json with org-babel."
    body)

  (use-package web-mode
    :demand t
    :config
    (:push auto-mode-alist '("\\.tsx\\'" . web-mode))
    (:push auto-mode-alist '("\\.jsx\\'" . web-mode))
    (:push auto-mode-alist '("\\.html?\\'" . web-mode))
    (:push web-mode-engines-alist '(("django"    . "\\.html\\'")))
    (:hook web-mode (progn (prettier-js-mode)
                           (setq web-mode-markup-indent-offset 4)))
    (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
    (setq-default flycheck-disabled-checkers
                  (append flycheck-disabled-checkers
                          '(javascript-jshint json-jsonlist)))
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    (add-hook 'after-init-hook #'global-flycheck-mode)
    (add-hook 'flycheck-mode-hook 'add-node-modules-path))
#+end_src

** go-mode
#+begin_src emacs-lisp
  (use-package go-mode
    :config (:hook go-mode
              (:hook before-save gofmt-before-save)
              (setq tab-width 4)
              (setq indent-tabs-mode 1)))
#+end_src

** csharp
#+begin_src emacs-lisp
  (use-package csharp-mode)

  (:hook csharp-mode :local
    (company-mode)
    (flycheck-mode)

    (setq c-syntactic-indentation t)
    (c-set-style "ellemtel")
    (setq c-basic-offset 4)
    (setq truncate-lines t)
    (setq tab-width 4)

    (electric-pair-local-mode 1))
#+end_src
** fsharp
#+begin_src emacs-lisp
  (use-package fsharp-mode
    :config
    (require 'eglot)
    (:push auto-mode-alist '("\\.fs[iylx]?$" . fsharp-mode)))
#+end_src

* tooling support
** docker
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :mode "Dockerfile\\'")
#+end_src

** nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :straight (nix-mode :type git :host github :repo "NixOS/nix-mode")
    :mode "\\.nix\\'"
    :config
    (remove-hook 'before-save-hook #'nix-mode-format))
#+end_src
*** nix-sandbox
#+begin_src emacs-lisp
  (use-package nix-sandbox)
#+end_src

* elfeed
** boilerplate
#+begin_src emacs-lisp
    (defun advice-unadvice (sym)
      "Remove all advices from symbol SYM."
      (interactive "aFunction symbol: ")
      (advice-mapc (lambda (advice _props) (advice-remove sym advice)) sym))

    (defun elfeed-font-size-hook ()
      (buffer-face-set '(:height 1.35)))

    (defun elfeed-visual-fill-hook ()
      (visual-fill-column-mode--enable))

    (defun elfeed-show-refresh-advice (entry)
      (elfeed-font-size-hook)
      (visual-fill-column-mode 1)
      (setq word-wrap 1)
      (elfeed-show-refresh))

    (defun elfeed-show ()
      (interactive)
      (elfeed)
      (delete-other-windows))
#+end_src

** setup
#+begin_src emacs-lisp
  (use-package elfeed
    :bind (("C-x w" . elfeed-show))
    :config
    (:hook elfeed-search-update elfeed-font-size-hook)
    (advice-unadvice 'elfeed-show-entry)
    (advice-add 'elfeed-show-entry :after 'elfeed-show-refresh-advice))

  (use-package elfeed-org
    :after (elfeed)
    :config
    (elfeed-org)
    (setq rmh-elfeed-org-files (list (my/get-org-file "notes.org"))))
#+end_src

* misc
Miscellaneous packages that don't really need their own section.

** embrace
#+begin_src emacs-lisp
  (use-package embrace
    :config
    (embrace-add-pair (kbd "\;") "`" "`"))
#+end_src

** htmlize
Allows org codeblocks to be syntax highlighted on html export.

#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

** emacsql
#+begin_src emacs-lisp
  (use-package emacsql-sqlite)
#+end_src

** gist
#+begin_src emacs-lisp
  (use-package gist
    :straight (gist :type git :host github :repo "defunkt/gist.el"))
#+end_src

** poker.el
#+begin_src emacs-lisp
  (use-package poker
    :straight (poker :type git :host github :repo "mlang/poker.el"))
#+end_src

** decide-mode
#+begin_src emacs-lisp
  (use-package decide
    :straight (decide :type git :host github :repo "lifelike/decide-mode"))
#+end_src

** lojban
#+begin_src emacs-lisp
  ;; (eval `(use-package sutysisku
  ;;    :demand t
  ;;    :straight (sutysisku :local-repo ,(my/get-project-directory "sutysisku.el/"))))
#+end_src

** plantuml
#+begin_src emacs-lisp
  (use-package plantuml-mode
    :config
    (setq plantuml-jar-path "/nix/store/slmi57xig7mbif52sf757arx5sbj2bni-plantuml-1.2020.15/lib/plantuml.jar")
    (setq plantuml-default-exec-mode 'jar))
#+end_src

* hydra
[[https://github.com/abo-abo/hydra][Hydra]] provides customizable interactive command palettes.

** pretty-hydra
[[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][Pretty-hydra]] provides a macro that makes it easy to get good looking hydras.

#+begin_src emacs-lisp
  (use-package pretty-hydra
    :demand t
    :straight (pretty-hydra :type git :host github
                            :repo "jerrypnz/major-mode-hydra.el"
                            :branch "c6554ea"
                            :files ("pretty-hydra.el")))
#+end_src

** major-mode-hydra
[[https://github.com/jerrypnz/major-mode-hydra.el][Major-mode-hydra]] associates hydras with major-modes.

#+begin_src emacs-lisp
  (use-package major-mode-hydra
    :straight (major-mode-hydra :type git :host github
                                :repo "jerrypnz/major-mode-hydra.el"
                                :branch "c6554ea"
                                :files ("major-mode-hydra.el")))
#+end_src

** hera
[[https://github.com/dustinlacewell/hera][Hera]] lets hydras form a stack.

#+begin_src emacs-lisp
  (use-package hera
    :demand t
    :straight (hera :type git :host github :repo "dustinlacewell/hera"))
#+end_src

** :hydra
Macro for defining Hydras.

*** boilerplate
**** inject-hint
#+begin_src emacs-lisp
  (defun :hydra/inject-hint (symbol hint)
    (-let* ((name (symbol-name symbol))
            (hint-symbol (intern (format "%s/hint" name)))
            (format-form (eval hint-symbol))
            (string-cdr (nthcdr 1 format-form))
            (format-string (string-trim (car string-cdr)))
            (amended-string (format "%s\n\n%s" format-string hint)))
      (setcar string-cdr amended-string)))
#+end_src

**** make-head-hint
#+begin_src emacs-lisp
  (defun :hydra/make-head-hint (head default-color)
    (-let (((key _ hint . rest) head))
      (when key
        (-let* (((&plist :color color) rest)
                (color (or color default-color))
                (face (intern (format "hydra-face-%s" color)))
                (propertized-key (propertize key 'face face)))
          (format " [%s]: %s" propertized-key hint)))))
#+end_src

**** make-hint
#+begin_src emacs-lisp
  (defun :hydra/make-hint (heads default-color)
    (string-join
     (cl-loop for head in heads
              for hint = (:hydra/make-head-hint head default-color)
              do (pp hint)
              collect hint) "\n"))
#+end_src

**** clear-hint
#+begin_src emacs-lisp
  (defun :hydra/clear-hint (head)
    (-let* (((key form _ . rest) head))
      `(,key ,form nil ,@rest)))
#+end_src

**** add-exit-head
#+begin_src emacs-lisp
  (defun :hydra/add-exit-head (heads)
    (let ((exit-head '("SPC" (hera-pop) "to exit" :color blue)))
      (append heads `(,exit-head))))
#+end_src

**** add-heads
#+begin_src emacs-lisp
    (defun :hydra/add-heads (columns extra-heads)
      (let* ((cell (nthcdr 1 columns))
             (heads (car cell))
             (extra-heads (mapcar ':hydra/clear-hint extra-heads)))
        (setcar cell (append heads extra-heads))))

#+end_src

*** macro
#+begin_src emacs-lisp
    (defmacro :hydra (name body columns &optional extra-heads)
      (declare (indent defun))
      (-let* (((&plist :color default-color :major-mode mode) body)
              (extra-heads (:hydra/add-exit-head extra-heads))
              (extra-hint (:hydra/make-hint extra-heads default-color))
              (body (plist-put body :hint nil))
              (body-name (format "%s/body" (symbol-name name)))
              (body-symbol (intern body-name))
              (mode-body-name (major-mode-hydra--body-name-for mode))
              (mode-support
               `(when ',mode
                  (defun ,mode-body-name () (interactive) (,body-symbol)))))
        (:hydra/add-heads columns extra-heads)
        (when mode
          (cl-remf body :major-mode))
        `(progn
           (pretty-hydra-define ,name ,body ,columns)
           (:hydra/inject-hint ',name ,extra-hint)
           ,mode-support
           )))
#+end_src

*** tests
#+begin_src emacs-lisp
    ;; (macroexpand-all `(:hydra hydra-test (:color red :major-mode fundamental-mode)
    ;;    ("First"
    ;;     (("a" (message "first - a") "msg a" :color blue)
    ;;      ("b" (message "first - b") "msg b"))
    ;;     "Second"
    ;;     (("c" (message "second - c") "msg c" :color blue)
    ;;      ("d" (message "second - d") "msg d")))))

    ;; (:hydra hydra-test (:color red :major-mode fundamental-mode)
    ;;    ("First"
    ;;     (("a" (message "first - a") "msg a" :color blue)
    ;;      ("b" (message "first - b") "msg b"))
    ;;     "Second"
    ;;     (("c" (message "second - c") "msg c" :color blue)
    ;;      ("d" (message "second - d") "msg d"))))

#+end_src

* default hydra
** hydra-bookmarks
#+begin_src emacs-lisp
  (:hydra hydra-bookmarks (:color blue)
    ("Bookmarks" (("n" (linkmarks-capture) "new")
                  ("b" (linkmarks-select) "browse")
                  ("e" (find-file my/bookmarks-file-name)))))
#+end_src
** hydra-help
Many of the Emacs help facilities at your fingertips!

#+begin_src emacs-lisp

  (:hydra hydra-help (:color blue)
    ("Describe"
     (("c" describe-function "function")
      ("p" describe-package "package")
      ("m" describe-mode "mode")
      ("v" describe-variable "variable"))
     "Keys"
     (("k" describe-key "key")
      ("K" describe-key-briefly "brief key")
      ("w" where-is "where-is")
      ("b" helm-descbinds "bindings"))
     "Search"
     (("a" helm-apropos "apropos")
      ("d" apropos-documentation "documentation")
      ("s" info-lookup-symbol "symbol info"))
     "Docs"
     (("i" info "info")
      ("n" helm-man-woman "man")
      ("h" helm-dash "dash"))
     "View"
     (("e" view-echo-area-messages "echo area")
      ("l" view-lossage "lossage")
      ("c" describe-coding-system "encoding")
      ("I" describe-input-method "input method")
      ("C" describe-char "char at point"))))
#+end_src

** hydra-mark
#+begin_src emacs-lisp
  (defun unpop-to-mark-command ()
    "Unpop off mark ring. Does nothing if mark ring is empty."
    (when mark-ring
      (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
      (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
      (when (null (mark t)) (ding))
      (setq mark-ring (nbutlast mark-ring))
      (goto-char (marker-position (car (last mark-ring))))))

  (defun push-mark ()
    (interactive)
    (set-mark-command nil)
    (set-mark-command nil))

  (:hydra hydra-mark (:color pink)
    ("Mark"
     (("m" push-mark "mark here")
      ("p" (lambda () (interactive) (set-mark-command '(4))) "previous")
      ("n" (lambda () (interactive) (unpop-to-mark-command)) "next")
      ("c" (lambda () (interactive) (setq mark-ring nil)) "clear"))))
#+end_src

** hydra-registers
#+begin_src emacs-lisp
  (:hydra hydra-registers (:color pink)
    ("Point"
     (("r" point-to-register "save point")
      ("j" jump-to-register "jump")
      ("v" view-register "view all"))
     "Text"
     (("c" copy-to-register "copy region")
      ("C" copy-rectangle-to-register "copy rect")
      ("i" insert-register "insert")
      ("p" prepend-to-register "prepend")
      ("a" append-to-register "append"))
     "Macros"
     (("m" kmacro-to-register "store")
      ("e" jump-to-register "execute"))))

#+end_src

** hydra-window
#+begin_src emacs-lisp
  (use-package ace-window)
  (winner-mode 1)

  (:hydra hydra-window (:color red)
    ("Jump"
     (("h" windmove-left "left")
      ("l" windmove-right "right")
      ("k" windmove-up "up")
      ("j" windmove-down "down")
      ("a" ace-select-window "ace"))
     "Split"
     (("q" split-window-right "left")
      ("r" (progn (split-window-right) (call-interactively 'other-window)) "right")
      ("e" split-window-below "up")
      ("w" (progn (split-window-below) (call-interactively 'other-window)) "down"))
     "Do"
     (("d" delete-window "delete")
      ("o" delete-other-windows "delete others")
      ("u" winner-undo "undo")
      ("R" winner-redo "redo")
      ("t" nougat-hydra-toggle-window "toggle"))))
#+end_src

** hydra-zoom
#+begin_src emacs-lisp
  (:hydra hydra-zoom (:color red)
    ("Buffer"
     (("i" text-scale-increase "in")
      ("o" text-scale-decrease "out"))
     "Frame"
     (("I" zoom-frm-in "in")
      ("O" zoom-frm-out "out")
      ("r" toggle-zoom-frame "reset" :color blue))))
#+end_src

** hydra-nix
#+begin_src emacs-lisp
  (:hydra hydra-nix (:color blue)
    ("Nix" (("p" (progn (find-file (my/get-org-file "nixpkgs.org"))
                        (helm-org-in-buffer-headings)
                        (recenter-top-bottom 1)
                        (org-narrow-to-subtree)
                        (sit-for 5)
                        (widen)) "nixpkgs"))))
#+end_src

** hydra-docs
#+begin_src emacs-lisp
  (:hydra hydra-docs (:color blue)
    ("Docs" (("n" (hera-push 'hydra-nix/body) "Nix"))))
#+end_src
** hydra-notes
#+begin_src emacs-lisp
  (require 'helm-org-walk)

  (:hydra hydra-notes (:color blue)
    ("Notes"
     (("o" (helm-org-walk '(4)) "open")
      ("s" (helm-org-rifle-org-directory) "search")
      ("S" (helm-org-rifle-occur-org-directory) "occur")
      ("q" (helm-org-ql-org-directory) "query")
      ("n" (helm-org-walk my/notes-file-name) "notes"))))
#+end_src

** hydra-gist
#+begin_src emacs-lisp
  (:hydra hydra-gist (:color blue)
    ("Gist" (("p" (gist-region-or-buffer) "public")
             ("P" (gist-region-or-buffer-private) "private")
             ("b" (browse-url "https://gist.github.com/dustinlacewell") "browse"))))
#+end_src

** hydra-projectile
#+begin_src emacs-lisp
  (:hydra hydra-projectile (:color blue)
    ("Open"
     (("o" (helm-projectile-switch-project) "project")
      ("p" (helm-projectile) "project asset")
      ("f" (helm-projectile-find-file-dwim) "file")
      ("b" (helm-projectile-switch-to-buffer) "buffer")
      ("r" (projectile-readme) "readme")
      ("w" (hydra-treemacs/body) "workspace"))
     "Do"
     (("s" (helm-projectile-ag) "search")
      ("c" (org-projectile-helm-template-or-project) "capture"))
     "Cache"
     (("C" projectile-invalidate-cache "clear cache")
      ("x" (projectile-remove-known-project) "remove this project")
      ("X" (projectile-cleanup-known-projects) "cleanup missing"))))
#+end_src

** hydra-default
#+begin_src emacs-lisp
  (:hydra hydra-default (:color blue)
    ("Open"
     (("a" (org-agenda nil "a") "agenda")
      ("p" (hera-push 'hydra-projectile/body) "projectile")
      ("o" (hera-push 'hydra-notes/body) "org")
      ("j" (call-interactively 'org-journal-new-entry) "new journal entry")
      ("J" (org-journal-new-entry '(4)) "open journal")
      ("b" (hera-push 'hydra-bookmarks/body) "bookmarks"))
     "Emacs"
     (("h" (hera-push 'hydra-help/body) "help")
      ("m" (hera-push 'hydra-mark/body) "mark")
      ("w" (hera-push 'hydra-window/body) "windows")
      ("z" (hera-push 'hydra-zoom/body) "zoom")
      ("r" (hera-push 'hydra-registers/body) "registers"))
     "Misc"
     (("d" (hera-push 'hydra-docs/body) "docs")
      ("g" (hera-push 'hydra-gist/body) "gist")
      (";" embrace-commander "embrace"))))
#+end_src

* modal hydras
** boilerplate
*** hydra-dwim
Open hydra for current major mode if one exists, otherwise the default hydra.
#+begin_src emacs-lisp
  (defun my/hydra-dwim ()
    (interactive)
    (let* ((mode major-mode)
          (orig-mode mode))
      (catch 'done
        (while mode
          (let ((hydra (major-mode-hydra--body-name-for mode)))
            (when (fboundp hydra)
              (hera-start hydra)
              (throw 'done t)))
          (setq mode (get mode 'derived-mode-parent)))
        (hera-start 'hydra-default/body))))
#+end_src
** hydra-yank-pop
#+begin_src emacs-lisp
  (:hydra hydra-yank-pop (:color red)
    ("Yank/Pop"
     (("y" (yank-pop 1) "previous")
      ("Y" (yank-pop -1) "next")
      ("l" helm-show-kill-ring "list" :color blue))))

  (:bind "C-y"
    (yank)
    (hydra-yank-pop/body))
#+end_src

** hydra-elisp
#+begin_src emacs-lisp
  (:hydra hydra-elisp (:color blue :major-mode emacs-lisp-mode)
    ("Execute"
     (("d" eval-defun "defun")
      ("b" eval-current-buffer "buffer")
      ("r" eval-region "region"))
     "Debug"
     (("D" edebug-defun "defun")
      ("a" edebug-all-defs "all definitions" :color red)
      ("A" edebug-all-forms "all forms" :color red)
      ("x" macrostep-expand "expand macro"))))
#+end_src

** hydra-tide
#+begin_src emacs-lisp
  (:hydra hydra-tide (:color blue :major-mode typescript-mode)
    ("Server"
     (("r" tide-restart-server "restart")
      ("k" tide-kill-server "kill")
      ("C" tide-do-cleanups "cleanup"))
     "Actions"
     (("f" tide-fix "fix")
      ("F" tide-cleanup-imports "format")
      ("r" tide-references "references")
      ("R" tide-rename-symbol "rename")
      ("e" tide-refactor "extract"))
     "Errors"
     (("p" tide-error-at-point "error at point")
      ("P" tide-project-errors "project errors"))))
#+end_src

** hydra-treemacs
#+begin_src emacs-lisp
  (:hydra hydra-treemacs (:color red)
    ("Workspace"
     (("o" treemacs-switch-workspace "open")
      ("n" treemacs-create-workspace "new")
      ("k" treemacs-delete-workspace "kill")
      ("r" treemacs-rename-workspace "rename"))))
#+end_src
** hydra-org
*** hydra-org-goto-first-sibling
#+begin_src emacs-lisp
  (defun hydra-org-goto-first-sibling () (interactive)
         (org-backward-heading-same-level 99999999))
#+end_src

*** hydra-org-goto-last-sibling
#+begin_src emacs-lisp
  (defun hydra-org-goto-last-sibling () (interactive)
         (org-forward-heading-same-level 99999999))
#+end_src

*** hydra-org-parent-level
#+begin_src emacs-lisp
  (defun hydra-org-parent-level ()
    (interactive)
    (let ((o-point (point)))
      (if (save-excursion
            (beginning-of-line)
            (looking-at org-heading-regexp))
          (progn
            (call-interactively 'outline-up-heading)
            (org-cycle-internal-local))
        (progn
          (call-interactively 'org-previous-visible-heading)
          (org-cycle-internal-local)))
      (when (and (/= o-point (point))
                 org-tidy-p)
        (call-interactively 'hydra-org-tidy))))

 #+end_src

*** hydra-org-child-level
#+begin_src emacs-lisp
  (defun hydra-org-child-level ()
    (interactive)
    (org-show-entry)
    (org-show-children)
    (when (not (org-goto-first-child))
      (when (save-excursion
              (beginning-of-line)
              (looking-at org-heading-regexp))
        (next-line))))
#+end_src

*** hydra-org
 #+begin_src emacs-lisp
   (:hydra hydra-org (:color red :major-mode org-mode)
     ("Shift"
      (("K" org-move-subtree-up "up")
       ("J" org-move-subtree-down "down")
       ("h" org-promote-subtree "promote")
       ("l" org-demote-subtree "demote"))
      "Travel"
      (("p" org-backward-heading-same-level "backward")
       ("n" org-forward-heading-same-level "forward")
       ("j" hydra-org-child-level "to child")
       ("k" hydra-org-parent-level "to parent")
       ("a" hydra-org-goto-first-sibling "first sibling")
       ("e" hydra-org-goto-last-sibling "last sibling"))
      "Perform"
      (("t" (org-babel-tangle) "tangle" :color blue)
       ("e" (org-html-export-to-html) "export" :color blue)
       ("b" helm-org-in-buffer-headings "browse")
       ("r" (lambda () (interactive)
              (helm-org-rifle-current-buffer)
              (org-cycle)
              (org-cycle)) "rifle")
       ("w" helm-org-walk "walk")
       ("v" avy-org-goto-heading-timer "avy")
       ("L" org-toggle-link-display "toggle links"))))
#+end_src

** hydra-js
#+begin_src emacs-lisp
  (defun js2r-toggle-async ()
    (interactive)
    (if (string-equal "async" (thing-at-point 'word))
        (progn
          (search-forward "function")
          (backward-word)))
    (js2r-toggle-function-async))

  (:hydra hydra-js (:color blue :major-mode js2-mode)
    ("Eval"
     (("f" js2-eval-defun "function")
      ("e" js2-eval "expression"))
     "Extract"
     (("f" js2r-extract-function "function")
      ("m" js2r-extract-method "method")
      ("v" js2r-extract-var "var")
      ("l" js2r-extract-let "let")
      ("c" js2r-extract-let "const"))
     "Funcs"
     (("a" js2r-toggle-arrow-function-and-expression "arrow" :color red)
      ("A" js2r-toggle-async "async" :color red)
      ("O" js2r-arguments-to-object "object param"))
     "Vars"
     (("r" js2r-rename-var "rename")
      ("i" js2r-inline-var "inline"))
     "Misc"
     (("k" js2r-kill "kill" :color red)
      ("t" js2r-string-to-template "string to template")
      ("l" js2r-log-this "log expr")
      ("w" js2r-wrap-buffer-in-iife "wrap in iife")
      ("G" js2r-inject-global-in-iife "global for iife"))))
#+end_src

* linux configuration
** preamble
#+begin_src emacs-lisp
  (when (string-equal system-type "gnu/linux")
#+end_src

** nixos
NixOS' ZSH module drops some PATH modification stuff in =~/.config/zsh/.zshrc=
which causes the following message on startup:

#+begin_src
  You appear to be setting environment variables ("PATH") in your .bashrc or .zshrc:
  those files are only read by interactive shells, so you should instead set
  environment variables in startup files like .profile, .bash_profile or .zshenv.
  Refer to your shell's man page for more info.

  Customize `exec-path-from-shell-arguments` to remove "-i" when done, or disable
  `exec-path-from-shell-check-startup-files` to disable this message.
#+end_src

The following line prevents the warning above:

#+begin_src emacs-lisp
  (setq exec-path-from-shell-check-startup-files nil)
#+end_src

** theme
#+begin_src emacs-lisp
  (load-file "~/.config/wpg/templates/theme.el")
  (enable-theme 'xresources)
  ;; (use-package dracula-theme
  ;;   :config (enable-theme 'dracula))
#+end_src

*** automatically update theme
#+begin_src emacs-lisp
  (defun theme-callback (event)
    (load-file "~/.config/wpg/templates/theme.el")
    (enable-theme 'xresources))

  (require 'filenotify)
  (setq theme-watch-handle
        (file-notify-add-watch
         "/home/ldlework/.config/wpg/templates/theme.el" '(change) 'theme-callback))
#+end_src

*** default font
#+begin_src emacs-lisp
  (setq powerline-height 32)
  (set-face-attribute 'default nil :family "New Times Roman" :weight 'light)
#+end_src

*** unicode fonts
#+begin_src emacs-lisp
  (use-package unicode-fonts
    :config
    (unicode-fonts-setup)
    (set-face-attribute 'default nil :font "Source Code Pro")
    ;(set-fontset-font "fontset-default" 'unicode "Consolas" nil)
    (set-fontset-font "fontset-default" 'unicode "DejaVu Sans Mono" nil)
    (set-fontset-font "fontset-default" 'unicode "Symbola" nil)
   )
#+end_src

** core
*** minor modes
**** ispell-minor-mode
#+begin_src emacs-lisp
  (setq ispell-program-name (concat my/home-directory ".nix-profile/bin/aspell"))
#+end_src

*** fix tooltips
#+begin_src emacs-lisp
  (setq x-gtk-use-system-tooltips nil)
#+end_src

** helm
*** theme customizations
#+begin_src emacs-lisp
  ;; (set-face-attribute
  ;;  'helm-selection nil
  ;;  :inherit t
  ;;  :background (theme-color 'blue)
  ;;  :foreground (theme-color 'background)
  ;;  :height 1.0
  ;;  :weight 'ultra-bold
  ;;  :inverse-video nil)

  ;; (set-face-attribute
  ;;  'helm-source-header nil
  ;;  :inherit nil
  ;;  :underline nil
  ;;  :background (theme-color 'background)
  ;;  :foreground (theme-color 'light-red)
  ;;  :height 1.9)

  ;; (set-face-attribute
  ;;  'helm-header nil
  ;;  :inherit nil
  ;;  :height 0.8
  ;;  :background (theme-color 'background)
  ;;  :foreground (theme-color 'cyan))

  ;; (set-face-attribute
  ;;  'helm-separator nil
  ;;  :height 0.8
  ;;  :foreground (theme-color 'light-red))

  ;; (set-face-attribute
  ;;  'helm-match nil
  ;;  :weight 'bold
  ;;  :foreground (theme-color 'green))

#+end_src

*** filter nix wrappers
#+begin_src emacs-lisp
(require 'helm-external)
(setq helm-external-commands-list
      (seq-filter (lambda (v) (not (string-match "^\\." v)))
                  (helm-external-commands-list-1 'sort)))
#+end_src

** postamble
#+begin_src emacs-lisp
  

  )
#+end_src

*** csharp
**** omnisharp
#+begin_src emacs-lisp
  (use-package omnisharp)

  (:after company
    (:push company-backends #'company-omnisharp))

  (defun my-linux-csharp-mode-setup ()
    (omnisharp-mode)
    (local-set-key (kbd "C-c r r") 'omnisharp-run-code-action-refactoring)
    (local-set-key (kbd "C-c C-c") 'recompile))

  (:hook csharp-mode my-linux-csharp-mode-setup t)
#+end_src

* windows configuration
** preamble
#+begin_src emacs-lisp
  (when (string-equal system-type "windows-nt")
#+end_src

** theme
#+begin_src emacs-lisp
  (use-package dracula-theme)
#+end_src

** postamble
#+begin_src emacs-lisp
)
#+end_src

* postfix
#+html_head: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+html_head: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+html_head: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+html_head: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+html_head: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+html_head: <link rel="stylesheet" href="https://raw.githubusercontent.com/gongzhitaao/orgcss/master/src/css/org.css">
#+NAME: startup
#+begin_src emacs-lisp
  (setq org-html-htmlize-output-type 'css)
  (setq org-html-head-include-default-style nil)
#+end_src

#+RESULTS: startup

#+begin_export html
<style>
h1 {
    font-size: 2.5em;
}

h2 {
    font-size: 2.3em;
    border-bottom: 1px solid black;
}

h3 {
    content: "\25CB";
    margin-right: .3em;
}
</style>
#+end_export

# Local Variables:
# eval: (progn (org-babel-goto-named-src-block "startup") (org-babel-execute-src-block) (outline-hide-sublevels 1))
# End:
